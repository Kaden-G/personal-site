---
import BaseLayout from "../../layouts/BaseLayout.astro";
---

<BaseLayout title="Cosmic Little Clash - Experiments">
  <div class="space-y-4">
    <div class="flex items-center justify-between">
      <h1 class="text-xl md:text-2xl font-semibold text-[#2A3D56]">Cosmic Little Clash</h1>
      <a href="/experiments" class="text-sm text-[#4B5563] hover:text-[#2A3D56]">‚Üê Back to Experiments</a>
    </div>
    <p class="text-sm md:text-base text-[#4B5563] max-w-2xl">
      A minimal turn-based physics game featuring three cosmic character types: Plasmids, Neonoids, and Voidlings.
    </p>

    <div class="flex flex-col items-center space-y-4 mt-6">
      <canvas id="gameCanvas" width="900" height="500" class="border-2 border-[#2A3D56] rounded-lg shadow-lg"></canvas>
      <div id="gameInfo" class="text-sm text-[#4B5563] text-center">
        <p>Click on the canvas to launch your active character!</p>
        <p id="turnInfo" class="font-semibold mt-2"></p>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
// ===== COSMIC LITTLE CLASH =====
const canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;
const turnInfo = document.getElementById('turnInfo')!;

// Constants
const GRAVITY = 0.3;
const GROUND_Y = 450;
const LAUNCH_POWER = 0.15;

// Character Types
type CharacterType = 'plasmid' | 'neonoid' | 'voidling';

interface Character {
  x: number;
  y: number;
  vx: number;
  vy: number;
  hp: number;
  type: CharacterType;
  team: number;
  radius: number;
  active: boolean;
}

// Game State
let characters: Character[] = [];
let currentTeam = 0;
let currentCharIndex = 0;
let stars: { x: number; y: number; size: number }[] = [];

// Initialize stars for background
function initStars() {
  for (let i = 0; i < 100; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 2
    });
  }
}

// Character Factories
function createPlasmid(x: number, y: number, team: number): Character {
  return {
    x, y, vx: 0, vy: 0, hp: 100, type: 'plasmid', team, radius: 25, active: false
  };
}

function createNeonoid(x: number, y: number, team: number): Character {
  return {
    x, y, vx: 0, vy: 0, hp: 100, type: 'neonoid', team, radius: 20, active: false
  };
}

function createVoidling(x: number, y: number, team: number): Character {
  return {
    x, y, vx: 0, vy: 0, hp: 100, type: 'voidling', team, radius: 22, active: false
  };
}

// Initialize Game
function initGame() {
  // Team 0
  characters.push(createPlasmid(150, 300, 0));
  characters.push(createNeonoid(250, 300, 0));

  // Team 1
  characters.push(createVoidling(650, 300, 1));
  characters.push(createPlasmid(750, 300, 1));

  characters[0].active = true;
  updateTurnInfo();
}

// Update turn information
function updateTurnInfo() {
  const activeChar = characters.find(c => c.active);
  if (activeChar) {
    turnInfo.textContent = `Team ${activeChar.team + 1}'s turn - ${activeChar.type.toUpperCase()}`;
  }
}

// Drawing Functions
function drawBackground() {
  // Dark space gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#0a0e27');
  gradient.addColorStop(1, '#1a1a3e');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw stars
  ctx.fillStyle = '#ffffff';
  stars.forEach(star => {
    ctx.globalAlpha = 0.5 + Math.random() * 0.5;
    ctx.fillRect(star.x, star.y, star.size, star.size);
  });
  ctx.globalAlpha = 1;
}

function drawGround() {
  ctx.strokeStyle = '#4a5568';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(canvas.width, GROUND_Y);
  ctx.stroke();
}

function drawPlasmid(char: Character) {
  // Jelly blob with glow
  const gradient = ctx.createRadialGradient(char.x, char.y, 0, char.x, char.y, char.radius);
  const color = char.team === 0 ? '#00ffaa' : '#ff00aa';
  gradient.addColorStop(0, color);
  gradient.addColorStop(0.7, color + '80');
  gradient.addColorStop(1, color + '20');

  ctx.fillStyle = gradient;
  ctx.beginPath();
  // Wobbly blob shape
  for (let i = 0; i <= 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const wobble = Math.sin(Date.now() * 0.003 + i) * 3;
    const r = char.radius + wobble;
    const x = char.x + Math.cos(angle) * r;
    const y = char.y + Math.sin(angle) * r;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fill();
}

function drawNeonoid(char: Character) {
  // Neon cube outline
  const color = char.team === 0 ? '#00ffff' : '#ff0088';
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.shadowColor = color;
  ctx.shadowBlur = 15;

  const size = char.radius * 1.5;
  ctx.strokeRect(char.x - size/2, char.y - size/2, size, size);

  // Inner glow
  ctx.strokeStyle = color + '40';
  ctx.strokeRect(char.x - size/3, char.y - size/3, size * 2/3, size * 2/3);

  ctx.shadowBlur = 0;
}

function drawVoidling(char: Character) {
  // Shadow blob
  const color = char.team === 0 ? '#6a0dad' : '#8b0000';
  const gradient = ctx.createRadialGradient(char.x, char.y, 0, char.x, char.y, char.radius);
  gradient.addColorStop(0, '#000000');
  gradient.addColorStop(0.5, color + '60');
  gradient.addColorStop(1, color + '20');

  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(char.x, char.y, char.radius, 0, Math.PI * 2);
  ctx.fill();

  // Glowing eyes
  ctx.fillStyle = '#ffff00';
  ctx.shadowColor = '#ffff00';
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.arc(char.x - 8, char.y - 5, 3, 0, Math.PI * 2);
  ctx.arc(char.x + 8, char.y - 5, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawCharacter(char: Character) {
  // Active indicator
  if (char.active) {
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(char.x, char.y, char.radius + 10, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Draw based on type
  switch (char.type) {
    case 'plasmid':
      drawPlasmid(char);
      break;
    case 'neonoid':
      drawNeonoid(char);
      break;
    case 'voidling':
      drawVoidling(char);
      break;
  }

  // HP bar
  const barWidth = char.radius * 2;
  const barHeight = 4;
  const barX = char.x - barWidth / 2;
  const barY = char.y - char.radius - 15;

  ctx.fillStyle = '#333';
  ctx.fillRect(barX, barY, barWidth, barHeight);
  ctx.fillStyle = char.hp > 50 ? '#00ff00' : char.hp > 25 ? '#ffff00' : '#ff0000';
  ctx.fillRect(barX, barY, (char.hp / 100) * barWidth, barHeight);
}

// Physics
function updatePhysics() {
  characters.forEach(char => {
    // Apply gravity
    char.vy += GRAVITY;

    // Update position
    char.x += char.vx;
    char.y += char.vy;

    // Ground collision
    if (char.y + char.radius > GROUND_Y) {
      char.y = GROUND_Y - char.radius;
      char.vy = -char.vy * 0.5; // Bounce with damping
      char.vx *= 0.8; // Friction

      if (Math.abs(char.vy) < 0.5) {
        char.vy = 0;
      }
    }

    // Wall collision
    if (char.x - char.radius < 0) {
      char.x = char.radius;
      char.vx = -char.vx * 0.5;
    }
    if (char.x + char.radius > canvas.width) {
      char.x = canvas.width - char.radius;
      char.vx = -char.vx * 0.5;
    }
  });
}

// Input Handler
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  const activeChar = characters.find(c => c.active);
  if (!activeChar) return;

  // Calculate direction from character to click
  const dx = clickX - activeChar.x;
  const dy = clickY - activeChar.y;

  // Apply impulse
  activeChar.vx = dx * LAUNCH_POWER;
  activeChar.vy = dy * LAUNCH_POWER;

  // Switch turn after a delay
  setTimeout(() => {
    activeChar.active = false;
    currentTeam = (currentTeam + 1) % 2;

    // Find next character on current team
    const teamChars = characters.filter(c => c.team === currentTeam && c.hp > 0);
    if (teamChars.length > 0) {
      teamChars[0].active = true;
      updateTurnInfo();
    }
  }, 2000);
});

// Game Loop
function update() {
  updatePhysics();
}

function render() {
  drawBackground();
  drawGround();
  characters.forEach(drawCharacter);
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

// Start Game
initStars();
initGame();
gameLoop();
</script>

<style>
  #gameCanvas {
    max-width: 100%;
    height: auto;
  }
</style>
