---
import BaseLayout from "../../layouts/BaseLayout.astro";
---

<BaseLayout title="Cosmic Little Clash - Experiments">
  <div class="space-y-4">
    <div class="flex items-center justify-between">
      <h1 class="text-xl md:text-2xl font-semibold text-[#2A3D56]">Cosmic Little Clash</h1>
      <a href="/experiments" class="text-sm text-[#4B5563] hover:text-[#2A3D56]">‚Üê Back to Experiments</a>
    </div>
    <p class="text-sm md:text-base text-[#4B5563] max-w-2xl">
      Battle on Mars with unique weapons! Choose your team and aim carefully to defeat your enemies.
    </p>

    <div class="flex flex-col items-center space-y-4 mt-6">
      <!-- Team Selection Screen -->
      <div id="teamSelect" class="bg-white p-6 rounded-lg shadow-lg border-2 border-[#2A3D56]">
        <h2 class="text-lg font-semibold text-[#2A3D56] mb-4 text-center">Choose Your Team</h2>
        <div class="flex gap-4 justify-center">
          <button id="selectPlasmid" class="team-btn p-4 border-2 border-[#00ffaa] rounded-lg hover:bg-[#00ffaa] hover:bg-opacity-10 transition-all">
            <div class="text-center">
              <div class="text-3xl mb-2">üíß</div>
              <div class="font-semibold text-[#00ffaa]">PLASMIDS</div>
              <div class="text-xs text-gray-600">Acid, Goo, Splash</div>
            </div>
          </button>
          <button id="selectNeonoid" class="team-btn p-4 border-2 border-[#00ffff] rounded-lg hover:bg-[#00ffff] hover:bg-opacity-10 transition-all">
            <div class="text-center">
              <div class="text-3xl mb-2">üì¶</div>
              <div class="font-semibold text-[#00ffff]">NEONOIDS</div>
              <div class="text-xs text-gray-600">Laser, Pulse, Beam</div>
            </div>
          </button>
          <button id="selectVoidling" class="team-btn p-4 border-2 border-[#6a0dad] rounded-lg hover:bg-[#6a0dad] hover:bg-opacity-10 transition-all">
            <div class="text-center">
              <div class="text-3xl mb-2">üëª</div>
              <div class="font-semibold text-[#6a0dad]">VOIDLINGS</div>
              <div class="text-xs text-gray-600">Shadow, Curse, Void</div>
            </div>
          </button>
        </div>
      </div>

      <canvas id="gameCanvas" width="900" height="500" class="border-2 border-[#2A3D56] rounded-lg shadow-lg" style="display:none;"></canvas>

      <!-- Weapon Selection UI -->
      <div id="weaponSelect" class="bg-white p-4 rounded-lg shadow-lg border-2 border-[#2A3D56]" style="display:none;">
        <h3 class="text-sm font-semibold text-[#2A3D56] mb-2 text-center">Choose Your Weapon</h3>
        <div id="weaponButtons" class="flex gap-2 justify-center"></div>
      </div>

      <div id="gameInfo" class="text-sm text-[#4B5563] text-center" style="display:none;">
        <p id="instructions">Choose a weapon, then click to aim and fire!</p>
        <p id="turnInfo" class="font-semibold mt-2"></p>
      </div>

      <!-- Game Over Screen -->
      <div id="gameOver" class="bg-white p-6 rounded-lg shadow-lg border-2 border-[#2A3D56]" style="display:none;">
        <h2 class="text-xl font-semibold text-[#2A3D56] mb-4 text-center" id="gameOverText"></h2>
        <button id="playAgain" class="px-6 py-2 bg-[#2A3D56] text-white rounded-lg hover:bg-[#3a4d66]">Play Again</button>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
// ===== COSMIC LITTLE CLASH =====
const canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;
const turnInfo = document.getElementById('turnInfo')!;
const instructions = document.getElementById('instructions')!;
const teamSelect = document.getElementById('teamSelect')!;
const weaponSelect = document.getElementById('weaponSelect')!;
const weaponButtons = document.getElementById('weaponButtons')!;
const gameInfo = document.getElementById('gameInfo')!;
const gameOver = document.getElementById('gameOver')!;
const gameOverText = document.getElementById('gameOverText')!;
const playAgain = document.getElementById('playAgain')!;

// Constants
const GRAVITY = 0.5;
const GROUND_Y = 420;

// Character Types
type CharacterType = 'plasmid' | 'neonoid' | 'voidling';
type WeaponType = string;

interface Character {
  x: number;
  y: number;
  vx: number;
  vy: number;
  hp: number;
  maxHp: number;
  type: CharacterType;
  team: number;
  radius: number;
  active: boolean;
  expression: 'happy' | 'focused' | 'angry' | 'hurt';
}

interface Weapon {
  name: string;
  damage: number;
  speed: number;
  size: number;
  color: string;
  effect: string;
}

interface Projectile {
  x: number;
  y: number;
  vx: number;
  vy: number;
  weapon: Weapon;
  team: number;
  active: boolean;
}

interface Plant {
  x: number;
  y: number;
  type: 'whoville' | 'truffula' | 'spiral';
  height: number;
  color: string;
  bendAngle: number;
}

interface Rock {
  x: number;
  y: number;
  width: number;
  height: number;
  color: string;
}

// Weapon definitions for each character type
const WEAPONS: Record<CharacterType, Weapon[]> = {
  plasmid: [
    { name: 'Acid Blob', damage: 20, speed: 8, size: 8, color: '#00ff00', effect: 'splash' },
    { name: 'Goo Ball', damage: 15, speed: 6, size: 12, color: '#00ffaa', effect: 'slow' },
    { name: 'Mega Splash', damage: 25, speed: 7, size: 10, color: '#00ff88', effect: 'burst' }
  ],
  neonoid: [
    { name: 'Laser Beam', damage: 22, speed: 12, size: 4, color: '#00ffff', effect: 'pierce' },
    { name: 'Pulse Wave', damage: 18, speed: 9, size: 6, color: '#0088ff', effect: 'wave' },
    { name: 'Power Beam', damage: 24, speed: 10, size: 5, color: '#00ccff', effect: 'electric' }
  ],
  voidling: [
    { name: 'Shadow Bolt', damage: 21, speed: 8, size: 7, color: '#6a0dad', effect: 'shadow' },
    { name: 'Dark Curse', damage: 16, speed: 7, size: 9, color: '#8b0000', effect: 'curse' },
    { name: 'Void Strike', damage: 26, speed: 9, size: 6, color: '#4a0080', effect: 'void' }
  ]
};

// Game State
let characters: Character[] = [];
let projectiles: Projectile[] = [];
let currentTeam = 0;
let plants: Plant[] = [];
let rocks: Rock[] = [];
let playerTeamType: CharacterType;
let enemyTeamType: CharacterType;
let gameStarted = false;
let selectedWeapon: Weapon | null = null;
let aimingMode = false;
let movementMode = false;
let hasMoved = false;
let mouseX = 0;
let mouseY = 0;

// Environment setup
function initEnvironment() {
  plants = [];
  rocks = [];

  // Add Dr. Seuss style plants
  const plantColors = ['#ff6b9d', '#ffaa00', '#00ff88', '#ff0088', '#00aaff', '#ff00ff'];
  for (let i = 0; i < 10; i++) {
    plants.push({
      x: Math.random() * canvas.width,
      y: GROUND_Y,
      type: ['whoville', 'truffula', 'spiral'][Math.floor(Math.random() * 3)] as any,
      height: 40 + Math.random() * 80,
      color: plantColors[Math.floor(Math.random() * plantColors.length)],
      bendAngle: (Math.random() - 0.5) * 0.5
    });
  }

  // Add Martian rocks (reddish)
  const rockColors = ['#8b4513', '#a0522d', '#cd5c5c', '#b8860b'];
  for (let i = 0; i < 8; i++) {
    rocks.push({
      x: Math.random() * canvas.width,
      y: GROUND_Y - Math.random() * 20,
      width: 30 + Math.random() * 50,
      height: 20 + Math.random() * 40,
      color: rockColors[Math.floor(Math.random() * rockColors.length)]
    });
  }
}

// Character Factories
function createCharacter(type: CharacterType, x: number, y: number, team: number): Character {
  return {
    x, y, vx: 0, vy: 0, hp: 100, maxHp: 100, type, team,
    radius: type === 'plasmid' ? 25 : type === 'neonoid' ? 20 : 22,
    active: false,
    expression: 'happy'
  };
}

// Initialize Game with selected teams
function initGame(playerType: CharacterType, enemyType: CharacterType) {
  characters = [];
  projectiles = [];

  // Player team (left side)
  const playerX1 = 100 + Math.random() * 50;
  const playerX2 = 150 + Math.random() * 50;
  characters.push(createCharacter(playerType, playerX1, 200, 0));
  characters.push(createCharacter(playerType, playerX2, 250, 0));

  // Enemy team (right side)
  const enemyX1 = 650 + Math.random() * 50;
  const enemyX2 = 700 + Math.random() * 50;
  characters.push(createCharacter(enemyType, enemyX1, 200, 1));
  characters.push(createCharacter(enemyType, enemyX2, 250, 1));

  characters[0].active = true;
  updateTurnInfo();
  startMovementPhase();
}

// Start movement phase
function startMovementPhase() {
  const activeChar = characters.find(c => c.active);
  if (!activeChar) return;

  if (activeChar.team === 0) {
    movementMode = true;
    hasMoved = false;
    weaponSelect.style.display = 'none';
    instructions.textContent = 'Click to move your character, then press SPACE to continue';
  } else {
    // AI movement
    aiMove();
  }
}

function aiMove() {
  const activeChar = characters.find(c => c.active && c.team === 1);
  if (!activeChar) return;

  // AI moves randomly
  const moveX = (Math.random() - 0.5) * 60;
  activeChar.vx = moveX * 0.3;
  activeChar.vy = -3;

  setTimeout(() => {
    showWeaponSelect();
  }, 1000);
}

// Update turn information
function updateTurnInfo() {
  const activeChar = characters.find(c => c.active);
  if (activeChar) {
    const teamName = activeChar.team === 0 ? 'Your' : 'Enemy';
    turnInfo.textContent = `${teamName} turn - ${activeChar.type.toUpperCase()}`;
  }
}

// Weapon Selection UI
function showWeaponSelect() {
  const activeChar = characters.find(c => c.active);
  if (!activeChar) return;

  weaponButtons.innerHTML = '';
  const weapons = WEAPONS[activeChar.type];

  weapons.forEach((weapon, index) => {
    const btn = document.createElement('button');
    btn.className = 'weapon-btn px-3 py-2 border-2 rounded-lg text-xs font-semibold transition-all';
    btn.style.borderColor = weapon.color;
    btn.style.color = weapon.color;
    btn.textContent = `${weapon.name} (${weapon.damage}dmg)`;
    btn.onclick = () => selectWeapon(weapon);
    weaponButtons.appendChild(btn);
  });

  if (activeChar.team === 0) {
    weaponSelect.style.display = 'block';
    aimingMode = false;
    selectedWeapon = null;
  } else {
    weaponSelect.style.display = 'none';
    // AI selects weapon
    setTimeout(() => {
      const randomWeapon = weapons[Math.floor(Math.random() * weapons.length)];
      aiAttack(randomWeapon);
    }, 1000);
  }
}

function selectWeapon(weapon: Weapon) {
  selectedWeapon = weapon;
  aimingMode = true;
  instructions.textContent = 'Aim with mouse - farther = more power! Click to fire!';

  // Highlight selected weapon
  Array.from(weaponButtons.children).forEach((btn, i) => {
    const weapons = WEAPONS[characters.find(c => c.active)!.type];
    if (weapons[i] === weapon) {
      (btn as HTMLElement).style.backgroundColor = weapon.color + '20';
    } else {
      (btn as HTMLElement).style.backgroundColor = 'transparent';
    }
  });
}

// Drawing Functions
function drawBackground() {
  // Martian sky gradient (orange/red)
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#ff9966');
  gradient.addColorStop(0.4, '#ff6b4a');
  gradient.addColorStop(1, '#cc5533');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Two suns
  ctx.fillStyle = '#ffee88';
  ctx.shadowColor = '#ffee88';
  ctx.shadowBlur = 40;
  ctx.beginPath();
  ctx.arc(150, 80, 35, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#ffaa44';
  ctx.shadowColor = '#ffaa44';
  ctx.shadowBlur = 25;
  ctx.beginPath();
  ctx.arc(750, 100, 22, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawGround() {
  // Martian desert (reddish-orange)
  const gradient = ctx.createLinearGradient(0, GROUND_Y, 0, canvas.height);
  gradient.addColorStop(0, '#cc6644');
  gradient.addColorStop(1, '#aa4422');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

  // Rocky texture
  ctx.fillStyle = '#994433';
  for (let i = 0; i < 60; i++) {
    const x = Math.random() * canvas.width;
    const y = GROUND_Y + Math.random() * 80;
    const size = Math.random() * 3;
    ctx.fillRect(x, y, size, size);
  }

  // Ground line
  ctx.strokeStyle = '#883322';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(canvas.width, GROUND_Y);
  ctx.stroke();
}

function drawPlants() {
  plants.forEach(plant => {
    ctx.save();
    ctx.translate(plant.x, plant.y);

    if (plant.type === 'whoville') {
      // Whoville-style curvy plant
      ctx.rotate(plant.bendAngle);
      ctx.strokeStyle = plant.color;
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(
        Math.sin(Date.now() * 0.001) * 20,
        -plant.height / 2,
        Math.sin(Date.now() * 0.002) * 30,
        -plant.height
      );
      ctx.stroke();

      // Pom-pom top
      ctx.fillStyle = plant.color;
      ctx.shadowColor = plant.color;
      ctx.shadowBlur = 10;
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const x = Math.sin(Date.now() * 0.002) * 30 + Math.cos(angle) * 12;
        const y = -plant.height + Math.sin(angle) * 12;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

    } else if (plant.type === 'truffula') {
      // Truffula tree style
      ctx.strokeStyle = '#8b4513';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -plant.height * 0.7);
      ctx.stroke();

      // Fluffy top
      ctx.fillStyle = plant.color;
      ctx.shadowColor = plant.color;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const puff = Math.sin(Date.now() * 0.003 + i) * 5;
        const x = Math.cos(angle) * (20 + puff);
        const y = -plant.height * 0.7 + Math.sin(angle) * (15 + puff);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

    } else {
      // Spiral plant
      ctx.strokeStyle = plant.color;
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';

      ctx.beginPath();
      for (let i = 0; i <= 20; i++) {
        const t = i / 20;
        const angle = t * Math.PI * 4 + Date.now() * 0.001;
        const radius = (1 - t) * 15;
        const x = Math.cos(angle) * radius;
        const y = -t * plant.height;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Star on top
      ctx.fillStyle = plant.color;
      const starY = -plant.height;
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
        const x = Math.cos(angle) * 8;
        const y = starY + Math.sin(angle) * 8;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }

    ctx.restore();
  });
}

function drawRocks() {
  rocks.forEach(rock => {
    // Main rock
    ctx.fillStyle = rock.color;
    ctx.fillRect(rock.x, rock.y - rock.height, rock.width, rock.height);

    // Highlight
    ctx.fillStyle = rock.color.replace(/[0-9a-f]{2}(?=[0-9a-f]{2}[0-9a-f]{2}$)/, (match) =>
      Math.min(255, parseInt(match, 16) + 30).toString(16).padStart(2, '0')
    );
    ctx.fillRect(rock.x, rock.y - rock.height, rock.width / 3, rock.height / 4);

    // Shadow
    ctx.fillStyle = '#00000030';
    ctx.fillRect(rock.x + rock.width * 0.6, rock.y - rock.height * 0.4, rock.width * 0.4, rock.height * 0.4);
  });
}

function drawPlasmid(char: Character) {
  const color = char.team === 0 ? '#00ffaa' : '#ff00aa';

  ctx.save();
  ctx.translate(char.x, char.y);

  const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, char.radius);
  gradient.addColorStop(0, color);
  gradient.addColorStop(0.7, color + '80');
  gradient.addColorStop(1, color + '20');
  ctx.fillStyle = gradient;

  ctx.beginPath();
  for (let i = 0; i <= 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const wobble = Math.sin(Date.now() * 0.003 + i) * 3;
    const r = char.radius + wobble;
    const x = Math.cos(angle) * r;
    const y = Math.sin(angle) * r;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fill();

  // Arms
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';

  const armWave = Math.sin(Date.now() * 0.005);
  ctx.beginPath();
  ctx.moveTo(-char.radius * 0.7, 0);
  ctx.lineTo(-char.radius * 1.2, armWave * 10);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(char.radius * 0.7, 0);
  ctx.lineTo(char.radius * 1.2, -armWave * 10);
  ctx.stroke();

  // Face
  ctx.fillStyle = '#000000';
  const eyeSize = char.expression === 'hurt' ? 2 : 4;
  ctx.beginPath();
  ctx.arc(-7, -5, eyeSize, 0, Math.PI * 2);
  ctx.arc(7, -5, eyeSize, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 2;
  ctx.beginPath();
  if (char.expression === 'happy') {
    ctx.arc(0, 0, 8, 0.2, Math.PI - 0.2);
  } else if (char.expression === 'hurt') {
    ctx.arc(0, 8, 8, Math.PI + 0.2, Math.PI * 2 - 0.2);
  } else {
    ctx.moveTo(-6, 5);
    ctx.lineTo(6, 5);
  }
  ctx.stroke();

  ctx.restore();
}

function drawNeonoid(char: Character) {
  const color = char.team === 0 ? '#00ffff' : '#ff0088';

  ctx.save();
  ctx.translate(char.x, char.y);

  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.shadowColor = color;
  ctx.shadowBlur = 15;

  const bodyWidth = char.radius * 1.5;
  const bodyHeight = char.radius * 1.8;
  ctx.strokeRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight);
  ctx.shadowBlur = 0;

  // Arms & Legs
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(-bodyWidth/2, -bodyHeight * 0.2);
  ctx.lineTo(-bodyWidth * 0.9, -bodyHeight * 0.3);
  ctx.moveTo(bodyWidth/2, -bodyHeight * 0.2);
  ctx.lineTo(bodyWidth * 0.9, -bodyHeight * 0.3);
  ctx.moveTo(-bodyWidth * 0.3, bodyHeight/2);
  ctx.lineTo(-bodyWidth * 0.4, bodyHeight * 0.8);
  ctx.moveTo(bodyWidth * 0.3, bodyHeight/2);
  ctx.lineTo(bodyWidth * 0.4, bodyHeight * 0.8);
  ctx.stroke();

  // Face
  ctx.fillStyle = color + '40';
  ctx.fillRect(-bodyWidth * 0.3, -bodyHeight * 0.35, bodyWidth * 0.6, bodyHeight * 0.4);

  ctx.fillStyle = color;
  if (char.expression === 'focused') {
    ctx.fillRect(-8, -10, 5, 3);
    ctx.fillRect(3, -10, 5, 3);
  } else if (char.expression === 'hurt') {
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, -10); ctx.lineTo(-4, -6);
    ctx.moveTo(-8, -6); ctx.lineTo(-4, -10);
    ctx.moveTo(4, -10); ctx.lineTo(8, -6);
    ctx.moveTo(4, -6); ctx.lineTo(8, -10);
    ctx.stroke();
  } else {
    ctx.fillRect(-8, -10, 4, 6);
    ctx.fillRect(4, -10, 4, 6);
  }

  if (char.expression === 'happy') {
    ctx.fillRect(-6, 2, 12, 2);
  }

  ctx.restore();
}

function drawVoidling(char: Character) {
  const color = char.team === 0 ? '#6a0dad' : '#8b0000';

  ctx.save();
  ctx.translate(char.x, char.y);

  const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, char.radius);
  gradient.addColorStop(0, '#1a1a1a');
  gradient.addColorStop(0.5, color + '60');
  gradient.addColorStop(1, color + '20');

  ctx.fillStyle = gradient;
  ctx.beginPath();

  for (let i = 0; i <= 16; i++) {
    const angle = (i / 16) * Math.PI * 2;
    let r = char.radius;

    if (angle > Math.PI * 0.3 && angle < Math.PI * 0.7) {
      r += Math.sin(Date.now() * 0.01 + i) * 5;
    }
    if (angle > Math.PI * 1.3 && angle < Math.PI * 1.7) {
      r += Math.sin(Date.now() * 0.01 + i) * 5;
    }

    const x = Math.cos(angle) * r;
    const y = Math.sin(angle) * r;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fill();

  // Arms
  ctx.strokeStyle = color + '80';
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';

  const float = Math.sin(Date.now() * 0.004) * 5;
  ctx.beginPath();
  ctx.moveTo(-char.radius * 0.6, 0);
  ctx.quadraticCurveTo(-char.radius * 0.9, float, -char.radius * 1.1, float - 5);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(char.radius * 0.6, 0);
  ctx.quadraticCurveTo(char.radius * 0.9, -float, char.radius * 1.1, -float + 5);
  ctx.stroke();

  // Eyes
  ctx.fillStyle = '#ffff00';
  ctx.shadowColor = '#ffff00';
  ctx.shadowBlur = 15;

  if (char.expression === 'angry') {
    ctx.beginPath();
    ctx.moveTo(-10, -8); ctx.lineTo(-6, -6); ctx.lineTo(-6, -10);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(10, -8); ctx.lineTo(6, -6); ctx.lineTo(6, -10);
    ctx.fill();
  } else if (char.expression === 'hurt') {
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.arc(-8, -6, 3, 0, Math.PI * 2);
    ctx.arc(8, -6, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  } else {
    ctx.beginPath();
    ctx.arc(-8, -6, 4, 0, Math.PI * 2);
    ctx.arc(8, -6, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.shadowBlur = 0;

  if (char.expression === 'happy') {
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(0, 2, 6, 0, Math.PI);
    ctx.fill();
  }

  ctx.restore();
}

function drawCharacter(char: Character) {
  if (char.active) {
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(char.x, char.y, char.radius + 15, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  switch (char.type) {
    case 'plasmid': drawPlasmid(char); break;
    case 'neonoid': drawNeonoid(char); break;
    case 'voidling': drawVoidling(char); break;
  }

  // HP bar
  const barWidth = char.radius * 2;
  const barHeight = 6;
  const barX = char.x - barWidth / 2;
  const barY = char.y - char.radius - 25;

  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(barX, barY, barWidth, barHeight);

  const hpPercent = char.hp / char.maxHp;
  ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
  ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barWidth, barHeight);
}

function drawProjectile(proj: Projectile) {
  ctx.save();
  ctx.translate(proj.x, proj.y);

  ctx.fillStyle = proj.weapon.color;
  ctx.shadowColor = proj.weapon.color;
  ctx.shadowBlur = 15;

  // Different shapes based on weapon effect
  if (proj.weapon.effect === 'pierce' || proj.weapon.effect === 'electric') {
    // Line/beam
    const angle = Math.atan2(proj.vy, proj.vx);
    ctx.rotate(angle);
    ctx.fillRect(-proj.weapon.size * 2, -proj.weapon.size / 2, proj.weapon.size * 3, proj.weapon.size);
  } else if (proj.weapon.effect === 'wave') {
    // Wave pattern
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const x = Math.cos(angle) * proj.weapon.size;
      const y = Math.sin(angle) * proj.weapon.size;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
  } else {
    // Regular circle
    ctx.beginPath();
    ctx.arc(0, 0, proj.weapon.size, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawAimLine() {
  if (!aimingMode || !selectedWeapon) return;

  const activeChar = characters.find(c => c.active && c.team === 0);
  if (!activeChar) return;

  const dx = mouseX - activeChar.x;
  const dy = mouseY - activeChar.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  // Calculate power based on distance (capped at 200 pixels for max power)
  const maxDist = 200;
  const power = Math.min(dist / maxDist, 1.5);
  const powerPercent = Math.min(power * 100, 150);

  // Calculate initial velocity (SLOWER for better visibility)
  const powerMultiplier = 0.08;
  const vx = dx * powerMultiplier;
  const vy = dy * powerMultiplier;

  // Draw trajectory arc (only one line - no double lines!)
  ctx.strokeStyle = selectedWeapon.color;
  ctx.lineWidth = 3;
  ctx.setLineDash([8, 4]);
  ctx.beginPath();
  ctx.moveTo(activeChar.x, activeChar.y);

  // Simulate trajectory
  let simX = activeChar.x;
  let simY = activeChar.y;
  let simVx = vx;
  let simVy = vy;

  for (let i = 0; i < 150; i++) {
    simVy += GRAVITY;
    simX += simVx;
    simY += simVy;

    ctx.lineTo(simX, simY);

    // Stop if hit ground or off screen
    if (simY >= GROUND_Y || simX < 0 || simX > canvas.width) {
      break;
    }
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // Power meter (circle around character)
  const meterRadius = 35;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(activeChar.x, activeChar.y, meterRadius, 0, Math.PI * 2);
  ctx.stroke();

  // Power fill
  const powerAngle = (power * Math.PI * 2);
  ctx.strokeStyle = power > 1 ? '#ff0000' : power > 0.7 ? '#ffff00' : '#00ff00';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(activeChar.x, activeChar.y, meterRadius, -Math.PI / 2, -Math.PI / 2 + powerAngle);
  ctx.stroke();

  // Power percentage text
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#000000';
  ctx.shadowBlur = 4;
  ctx.fillText(`${Math.round(powerPercent)}%`, activeChar.x, activeChar.y - meterRadius - 10);
  ctx.shadowBlur = 0;

  // Crosshair at mouse
  ctx.strokeStyle = selectedWeapon.color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(mouseX - 10, mouseY);
  ctx.lineTo(mouseX + 10, mouseY);
  ctx.moveTo(mouseX, mouseY - 10);
  ctx.lineTo(mouseX, mouseY + 10);
  ctx.stroke();
}

// Physics & Game Logic
function updateCharacterPhysics() {
  characters.forEach(char => {
    // Apply gravity
    char.vy += GRAVITY;

    // Update position
    char.x += char.vx;
    char.y += char.vy;

    // Ground collision
    if (char.y + char.radius > GROUND_Y) {
      char.y = GROUND_Y - char.radius;
      char.vy = 0;
      char.vx *= 0.85; // Friction

      if (Math.abs(char.vx) < 0.1) {
        char.vx = 0;
      }
    }

    // Wall collision
    if (char.x - char.radius < 0) {
      char.x = char.radius;
      char.vx = 0;
    }
    if (char.x + char.radius > canvas.width) {
      char.x = canvas.width - char.radius;
      char.vx = 0;
    }
  });
}

function updateProjectiles() {
  projectiles.forEach(proj => {
    if (!proj.active) return;

    proj.vy += GRAVITY;
    proj.x += proj.vx;
    proj.y += proj.vy;

    // Check ground collision
    if (proj.y > GROUND_Y) {
      proj.active = false;
    }

    // Check character collision
    characters.forEach(char => {
      if (char.team === proj.team) return;

      const dx = char.x - proj.x;
      const dy = char.y - proj.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < char.radius + proj.weapon.size) {
        // Hit!
        const luck = 0.8 + Math.random() * 0.4; // 80-120% damage (luck factor)
        const damage = Math.round(proj.weapon.damage * luck);
        char.hp = Math.max(0, char.hp - damage);
        char.expression = 'hurt';
        proj.active = false;

        setTimeout(() => {
          if (char.hp > 0) char.expression = 'happy';
        }, 500);

        checkGameOver();
      }
    });

    // Remove off-screen projectiles
    if (proj.x < 0 || proj.x > canvas.width || proj.y < 0) {
      proj.active = false;
    }
  });

  projectiles = projectiles.filter(p => p.active);
}

function checkGameOver() {
  const team0Alive = characters.filter(c => c.team === 0 && c.hp > 0).length;
  const team1Alive = characters.filter(c => c.team === 1 && c.hp > 0).length;

  if (team0Alive === 0) {
    endGame(false);
  } else if (team1Alive === 0) {
    endGame(true);
  }
}

function endGame(playerWon: boolean) {
  gameStarted = false;
  canvas.style.display = 'none';
  weaponSelect.style.display = 'none';
  gameInfo.style.display = 'none';
  gameOver.style.display = 'flex';
  gameOver.style.flexDirection = 'column';
  gameOver.style.alignItems = 'center';

  if (playerWon) {
    gameOverText.textContent = 'üéâ Victory! You defeated the enemy team!';
    gameOverText.style.color = '#00aa00';
  } else {
    gameOverText.textContent = 'üíÄ Defeat! Your team was destroyed!';
    gameOverText.style.color = '#aa0000';
  }
}

function nextTurn() {
  const activeChar = characters.find(c => c.active);
  if (activeChar) {
    activeChar.active = false;
    activeChar.expression = 'happy';
  }

  currentTeam = (currentTeam + 1) % 2;

  // Find next alive character
  const teamChars = characters.filter(c => c.team === currentTeam && c.hp > 0);
  if (teamChars.length > 0) {
    teamChars[0].active = true;
    updateTurnInfo();
    selectedWeapon = null;
    aimingMode = false;
    movementMode = false;
    hasMoved = false;
    startMovementPhase();
  }
}

function drawMovementIndicator() {
  if (!movementMode) return;

  const activeChar = characters.find(c => c.active && c.team === 0);
  if (!activeChar) return;

  // Draw movement range circle
  ctx.strokeStyle = hasMoved ? '#888888' : '#ffff00';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.arc(activeChar.x, activeChar.y, 100, 0, Math.PI * 2);
  ctx.stroke();
  ctx.setLineDash([]);

  // Crosshair at mouse
  if (!hasMoved) {
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(mouseX - 10, mouseY);
    ctx.lineTo(mouseX + 10, mouseY);
    ctx.moveTo(mouseX, mouseY - 10);
    ctx.lineTo(mouseX, mouseY + 10);
    ctx.stroke();
  }
}

// Player Attack
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

canvas.addEventListener('click', (e) => {
  if (!gameStarted) return;

  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  const activeChar = characters.find(c => c.active && c.team === 0);
  if (!activeChar) return;

  // Movement mode - click to jump toward location
  if (movementMode && !hasMoved) {
    const dx = clickX - activeChar.x;
    const dy = clickY - activeChar.y;

    // Apply jump force
    const jumpMultiplier = 0.08;
    activeChar.vx = dx * jumpMultiplier;
    activeChar.vy = dy * jumpMultiplier - 2; // Add upward boost

    hasMoved = true;
    instructions.textContent = 'Press SPACE to continue to weapon selection';
    return;
  }

  // Aiming mode - click to fire
  if (aimingMode && selectedWeapon) {
    const dx = clickX - activeChar.x;
    const dy = clickY - activeChar.y;

    // Power based on distance (SLOWER for visibility)
    const powerMultiplier = 0.08;
    const vx = dx * powerMultiplier;
    const vy = dy * powerMultiplier;

    projectiles.push({
      x: activeChar.x,
      y: activeChar.y,
      vx, vy,
      weapon: selectedWeapon,
      team: 0,
      active: true
    });

    activeChar.expression = 'focused';
    aimingMode = false;
    weaponSelect.style.display = 'none';

    setTimeout(nextTurn, 1500);
  }
});

// Spacebar to end movement phase
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && movementMode && hasMoved) {
    e.preventDefault();
    movementMode = false;
    showWeaponSelect();
  }
});

// AI Attack
function aiAttack(weapon: Weapon) {
  const activeChar = characters.find(c => c.active && c.team === 1);
  if (!activeChar) return;

  const playerChars = characters.filter(c => c.team === 0 && c.hp > 0);
  if (playerChars.length === 0) return;

  const target = playerChars[Math.floor(Math.random() * playerChars.length)];

  // AI aims with some inaccuracy
  const dx = target.x - activeChar.x + (Math.random() - 0.5) * 80;
  const dy = target.y - activeChar.y + (Math.random() - 0.5) * 60;

  // Power based on distance (SLOWER like player)
  const powerMultiplier = 0.08;
  const vx = dx * powerMultiplier;
  const vy = dy * powerMultiplier;

  projectiles.push({
    x: activeChar.x,
    y: activeChar.y,
    vx, vy,
    weapon: weapon,
    team: 1,
    active: true
  });

  activeChar.expression = 'angry';

  setTimeout(nextTurn, 1500);
}

// Game Loop
function update() {
  if (!gameStarted) return;
  updateCharacterPhysics();
  updateProjectiles();
}

function render() {
  drawBackground();
  drawGround();
  drawRocks();
  drawPlants();
  if (gameStarted) {
    characters.forEach(drawCharacter);
    projectiles.forEach(drawProjectile);
    drawMovementIndicator();
    drawAimLine();
  }
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

// Team Selection
document.getElementById('selectPlasmid')!.addEventListener('click', () => startGame('plasmid'));
document.getElementById('selectNeonoid')!.addEventListener('click', () => startGame('neonoid'));
document.getElementById('selectVoidling')!.addEventListener('click', () => startGame('voidling'));

function startGame(playerType: CharacterType) {
  playerTeamType = playerType;

  const types: CharacterType[] = ['plasmid', 'neonoid', 'voidling'];
  const remaining = types.filter(t => t !== playerType);
  enemyTeamType = remaining[Math.floor(Math.random() * remaining.length)];

  teamSelect.style.display = 'none';
  canvas.style.display = 'block';
  gameInfo.style.display = 'block';
  gameOver.style.display = 'none';

  gameStarted = true;
  initGame(playerTeamType, enemyTeamType);
}

// Play Again
playAgain.addEventListener('click', () => {
  gameOver.style.display = 'none';
  teamSelect.style.display = 'block';
  initEnvironment();
});

// Start
initEnvironment();
gameLoop();
</script>

<style>
  #gameCanvas {
    max-width: 100%;
    height: auto;
    cursor: crosshair;
  }

  .team-btn, .weapon-btn {
    cursor: pointer;
    transform: scale(1);
    transition: transform 0.2s, background-color 0.2s;
  }

  .team-btn:hover, .weapon-btn:hover {
    transform: scale(1.05);
  }

  .team-btn:active, .weapon-btn:active {
    transform: scale(0.95);
  }

  #weaponSelect {
    animation: slideUp 0.3s ease-out;
  }

  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  #playAgain {
    cursor: pointer;
    transition: all 0.2s;
  }

  #playAgain:hover {
    transform: scale(1.05);
  }
</style>
